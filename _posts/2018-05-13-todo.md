---
layout: post
title:  "Why Palindromes are Tricky"
date:   2018-05-13
---

Who doesn't like [palindromes][pali-wiki]? Those fun words which, read from right to left, are still the original word: "Anna", "Bob", "madam", "racecar" to name only a few. What makes them even better: writing a program to check if a word is a palindrome seems like a great task for every beginner trying to learn programming. But due to the complexity of human language and the way computers store strings, this task is way more difficult than most would assume. And as we will see, it is actually impossible to give a clear *yes*/*no* answer for many strings.

<div class="tldr" markdown="1">
# üîë Key takeaways
- TODO
</div>

---

<!--This post is split into two parts: first, I'll discuss human language itself and try to explain that the concept "palindrome" is not well defined in several languages, scripts or cultures. In the second part, I will go into the details of how we store text in computers and how different programming languages handle text. For a bunch of languages, I will show the naive implementation of the "palindrome algorithm" and explain how and why it's broken.-->


# Languages and Palindromes

Let's start with [the Wikipedia definition of *palindrome*](https://en.wikipedia.org/wiki/Palindrome):

> A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward [...].

Sounds easy enough! Written text is just a sequence of characters anyway, right? So let's count characters:

- "cat" ‚Üí 3, easy.
- "Ô¨Åre" ‚Üí 4, no problem. Oh wait ... what is the *f* doing with the *i* there?

This is called a [*ligature*](https://en.wikipedia.org/wiki/Typographic_ligature) and it describes the combination of two (or more) characters into a single one. This is said to improve readability or just to make the text look awesome. In [the font used for this blog][merriweather], the difference between the ligature and an *f* followed by an *i* is minimal. But you can see it clearly when using monofont: `Ô¨Å` vs. `fi`. Also: try selecting the text "Ô¨Åre": you cannot select the `i` alone.

<center>
    <img src="/assets/latex-ligature.png" style="width:50%;max-width:400px;border:none;margin:10px;"/>
    <em style="margin-top: 0px">Two ligatures in the output of LaTeX (font: <i>Computer Modern</i>)</em>
</center>

Many characters we treat as single character today actually started of as a ligture. For example, the *ampersand* character `&` developed as a ligature of `e` and `t` ("et" is the Latin word for "and"). In German, we have [the `√ü` character](https://en.wikipedia.org/wiki/%C3%9F) (often called *eszett* or *scharfes S*) which is actually a ligature made of `s` and `z`.


So what does this say about our character count?


# BS

For now, let's focus on single words. In particular, many palindrome sentences such as "Was it a car or a cat I saw?" require us to reorder spaces and punctuation to make it work. This gives us our first simple algorithm:

```
is_palindrome(word):
    word == reverse(word)
```

Oh but wait, "Bob" is a palindrome, right? But `reverse("Bob")` is `"boB"` which is not equal to `"Bob"`. So we have to compare `word` and `reverse(word)` in a case-insensitive way. We can easily do this by first converting both to lowercase and then comparing




[pali-wiki]: https://en.wikipedia.org/wiki/Palindrome
[merriweather]: https://fonts.google.com/specimen/Merriweather
