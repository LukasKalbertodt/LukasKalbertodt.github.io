---
layout: post
title:  "TODO: GATs"
date:   2018-07-18
---

**G**eneric **A**ssociated **T**ypes (GATs for short) are a long awaited extension to Rust's type system. They allow working with higher kinded types (HKTs) making it possible to express certain useful things in the type system. A common example is the "streaming iterator" -- an iterator able to return items borrowing from `self` (the iterator itself). Unfortunately, GATs haven't even landed in nightly yet. So while we wait, we can try tackling the streaming iterator problem without GATs. In this post we explore three possible workarounds for problems like situations where an associated type depends on the lifetime of a `&self` receiver.

<div class="tldr" markdown="1">
# ðŸ”‘ Key takeaways
- foo
- bar
</div>


---

TODO:
- not for beginners
- fairly long
- we discuss advantages and disadvantages
- table of contents
- we will redefine iterator trait
- mentions that there are plenty of similar problems
- I need this in a code base

Questions:
- The GAT version of Iterator, would `self` always count as borrowed, even tho `Item` doesn't use the lifetime? That would suck

# The problem

Let's quickly recap the problem we're trying to solve. Let's take a look at [`std::io::Lines`](https://doc.rust-lang.org/stable/std/io/struct.Lines.html): an iterator that can iterate over lines of a [`io::BufRead`](https://doc.rust-lang.org/stable/std/io/trait.BufRead.html). It's very useful, but has a major problem: it returns `io::Result<String>`. This means that a new `String` object is allocated for every line, making the iterator pretty slow. This is a common pitfall and source of confusion (for example, see [this question on StackOverflow](https://stackoverflow.com/q/45455275/2408867)).

## A better `io::Lines`

The better solution would be to manage a `String` buffer in the iterator and yielding `io::Result<&str>` as item. That way the allocated buffer is reused for all lines. So why doesn't `io::Lines` do that? Let's try it:

```rust
struct Lines<B: BufRead> {
    reader: B,
    buffer: String,
}

impl<B: BufRead> Iterator for Lines<B> {
    type Item = io::Result<&str>;
    fn next(&mut self) -> Option<Self::Item> { â€¦ }
}
```

Compiling this results in:

```
error[E0106]: missing lifetime specifier
   |
10 |     type Item = io::Result<&str>;
   |                            ^ expected lifetime parameter
```

We can't just omit lifetime parameters, except in functions where lifetime elision kicks in. What lifetime do we need to specify? The lifetime of `&self`, as the `&str` is borrowed from the `String` in `Lines`. But this is not possible!

```rust
impl<B: BufRead> Iterator for Lines<B> {
    type Item = io::Result<&'s str>;
    fn next<'s>(&'s mut self) -> Option<Self::Item> { â€¦ }
}
```

this results in `undeclared lifetime` as the lifetime `'s` is only visible in the scope of the function definition.

With GATs, we can easily solve this problem (if we were to redefine the `Iterator` trait!):

```rust
trait IteratorGat {
    type Item<'s>;
    fn next<'s>(&'s mut self) -> Option<Self::Item<'s>>;
    // ^ or just remove lifetimes in the function signature: lifetime
    // elision is able to handle this
}

impl<B: BufRead> Iterator for Lines<B> {
    type Item<'s> = io::Result<&'s str>;
    fn next<'s>(&'s mut self) -> Option<Self::Item<'s>> { â€¦ }
}
```


## Another useful example: mutable windows of a slice

In the case of `io::Lines` we want to return a reference to memory inside the iterator. But using the `self` lifetime can be used in other situations as well, making it possible to safely express certain things. A good example is a `WindowsMut` iterator. Already today there exists [`slice::Windows`](https://doc.rust-lang.org/stable/std/slice/struct.Windows.html) which is an iterator yielding overlapping windows of a slice. For example, `[1, 2, 3, 4].windows(2)` would yield the elements `&[1, 2]`, `&[2, 3]` and `&[3, 4]`.

Sometimes it would be useful to have a `WindowsMut`, yielding mutable overlapping windows of a slice. But this, again, is not possible with the current iterator trait. The following simple example shows that we could easily break the world:

```rust
let mut slice = ['a', 'ðŸ’£', 'c'];
let mut it = slice.windows_mut(2);
let x = it.next().unwrap();
let y = it.next().unwrap();

// Oops, now we have two mutable references to the second element:
// `&mut x[1]` and `&mut y[0]`
```

The above example would work because `x` is not borrowed from `it`, so `it` is not "locked" as mutably borrowed. Thus the compiler let's us happily call `next()` a second time. Fortunately, it's not possible to write such an `Iterator` implementation in safe Rust. Trying it always results in errors ([see on Playground](https://play.rust-lang.org/?gist=ea50e340ee159d722aadaa1ed9695921&version=stable&mode=debug&edition=2015)).

With GATs it would be possible to have `WindowsMut` as the compiler would understand that the item is borrowed from the iterator. As such, a second `next()` call wouldn't be allowed while an item still existed.

## Not the solution we want: the crate `streaming-iterator`

[The crate `streaming-iterator`](https://crates.io/crates/streaming-iterator) works around this limitation by defining [this trait](https://docs.rs/streaming-iterator/0.1.4/streaming_iterator/trait.StreamingIterator.html):

```rust
pub trait StreamingIterator {
    type Item: ?Sized;
    fn advance(&mut self);
    fn get(&self) -> Option<&Self::Item>;   // <-- reference
}
```

This main point to notice is that `Self::Item` is always returned by reference and not by value. This is certainly useful in some situations, but now the trait doesn't allow returning items by value -- which is also a limitation. Thus this solution requires two traits to work in all situations.

That's not what we want. **In this post we are interested in solutions that only require one trait and where the impl can choose whether or not the `Item` borrows from `self`.** This will solve a range of other problems as well, instead of only the streaming iterator one.


<br />
<br />


# First workaround: lifetime parameter in trait

Our first idea is to put the lifetime parameter on the trait itself and using it in the `self` parameter:

```rust
trait Iterator<'s> {
    type Item;
    fn next(&'s mut self) -> Option<Self::Item>;
}
```

This allows to use the lifetime parameter in the `Item` definition. But it also allows to ignore the lifetime parameter and have an `Item` that doesn't borrow from `self`:

```rust
impl<'s, B: BufRead> Iterator<'s> for Lines<B> {
    // Streaming iterator: we borrow from `self`
    type Item = io::Result<&'s str>;
    fn next(&'s mut self) -> Option<Self::Item> { â€¦ }
}

impl<'s> Iterator<'s> for Fibonacci {
    // "Normal" iterator: not borrowing from self
    type Item = u64;
    fn next(&'s mut self) -> Option<Self::Item> { â€¦ }
}
```

This is very promising! With the Fibonacci iterator, we can have multiple items at the same time, which is perfectly safe. On the other hand, we cannot have two items at the same time from the `Lines` iterator, which is also desired behavior (remember: there is only one string buffer, so we only store one line at a time).

```rust
let mut fib = Fibonacci::new();
let a = fib.next().unwrap();
let b = fib.next().unwrap(); // <-- works


let reader = io::Cursor::new(b"abc\ndef\nghi");
let mut lines = Lines::new(reader);
let line_1 = lines.next();
let line_2 = lines.next();  // <-- error: cannot borrow `lines` as mutable
                            //     more than once at a time
```

## Disadvantages

However, there are several problems with this workaround. First of all: the trait has a lifetime parameter. This means that a lifetime parameter is necessary every time the trait is used (as bound, for example). Let's try to write a function that counts the number of items in an iterator:

```rust
fn count<I>(mut iter: I) -> usize
where
    I: Iterator<'?>,  // <-- we need a lifetime
{ â€¦ }
```

There are multiple ways one could try to solve this:

- **`fn count<'s, I: Iterator<'s>>(mut iter: I)` (lifetime parameter in the function)**: this doesn't work. Generic parameters of the functions are choosen by the caller, not the callee. The problem is that we own the iterator (it lives in our stack frame) and thus we have to choose the lifetime. The caller couldn't possibly know the correct lifetime. And indeed, we get a compiler error.

  It's also important to note that this doesn't work because traits are invariant in respect to their parameters. So if we know that a type implements `Iterator<'x>`, we can't know if the type also implements `Iterator<'y>` for any lifetime `'y != 'x` (even if `'y` outlives `'x` or the other way around).

- **`I: for<'s> Iterator<'s>` (HRTBs)**: with the higher ranked trait bounds syntax we say that `I` needs to implement `Iterator<'s>` for every possible lifetime. Now we can choose the fitting lifetime for our stack frame and call `next()`. Good!

  But we have a new problem: requiring the trait bound for all possible lifetimes is pretty restricting. What we actually would like to say is "for all lifetimes outlived by `I`, `I` has to implement `Iterator`" (but it's impossible to express this). The iterator `impl`s we have seen so far won't cause problems, but imagine how the `impl` for `WindowsMut` would look like:

  ```rust
  impl<'a, 's, T: 's> Iterator<'s> for WindowsMut<'a, T> {
      type Item = &'s mut [T];
      â€¦
  }
  ```

  Here, the `T: 's` bound is required to be able to express the reference for `Item`. But this restricts the `impl`! This bound plus `for<'s> Iterator<'s>` is equivalent to `for<'s> T: 's` which also includes `T: 'static`. The effect is that `count` only works with `WindowsMut` if `T` is `'static`. Needlessly restrictive!
- **`fn count<'s, I>(iter: &'s mut I)` (iterator by reference)**: this time we allow the caller the choose the lifetime by passing the iterator by reference. In theory, this is good: now the iterator doesn't live in our stackframe and the reference we get already has the correct lifetime for the `next()` call.

  And indeed, we can call `next()`. *Once*. Since the `next()` call requires a mutable `self`, calling it a second time results in a "cannot borrow `*iter` as mutable more than once at a time". I won't get into the details here, but this is simply how the borrow checker works. Usually the borrow checker will try to find the smallest possible lifetime for a call to "block" the reference for the smallest possible time/scope. But in this case, there is only one possible lifetime for the call: `'s`. Again: traits are invariant over their parameters, so the compiler doesn't have a choice.

  This is not a problem for methods with immutable receiver, so there are situations where this works. However, this is only possible if you are able to take the object by reference. Sometimes that's not possible!

Furthermore, adding bounds for the associated type (`Item`) is not fun. Take a look at this:

```rust
where
    I: for<'s> Iterator<'s>,
    I::Item: Clone, // <-- error: cannot extract an associated type from a
                    //     higher-ranked trait bound in this context
```

Instead you have to write:

```rust
where
    I: for<'s> Iterator<'s>,
    for<'s> <I as Iterator<'s>>::Item: Clone,
```

Great!

<small markdown="1">(This problem could be solved by [RFC 2289](https://github.com/rust-lang/rfcs/pull/2289), but that's also not yet implemented...)</small>

## Rating

You can get fairly far with this workaround, but there are a ton of annoyances and eventually you'll hit a real limitation you cannot work around. Having a lifetime parameter in the trait is also semantically wrong and pollutes signatures everywhere.

I worked with this approach for a few weeks in my codebase and nearly lost my mind. Frequent super strange lifetime errors are not fun...

You can play with this workaround in [this playground](https://play.rust-lang.org/?gist=b366685a47e465b1baa4d25df9c0dadd&version=stable&mode=debug&edition=2015). It includes most of the code shown above.

<br />
<br />

# Second workaround: HRTBs and the family pattern

# Third workaround: wrapper types with the family pattern (TODO)



[gats-tracking-issue]: https://github.com/rust-lang/rust/issues/44265
