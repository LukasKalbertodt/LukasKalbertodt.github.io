---
layout: post
title:  "TODO: GATs"
date:   2018-07-18
---

**G**eneric **A**ssociated **T**ypes (GATs for short) are a long awaited extension to Rust's type system. With GATs it will be possible to work with higher kinded types (HKTs) -- a necessity in a couple of situations. A common example is the "streaming iterator": an iterator able to return items borrowing from `self` (the iterator itself). Unfortunately, GATs haven't even landed in nightly yet. So while we wait, we can try tackling the streaming iterator problem without GATs. In this post we explore three possible workarounds for situations where an associated type depends on the lifetime of a `&self` receiver.

<div class="tldr" markdown="1">
# ðŸ”‘ Key takeaways
- foo
- bar
</div>


---

# Target audience and "how to read?"

This post is targetted at somewhat experienced Rust programmers. Familiarity with Rust and a rough understanding of HKTs is assumed.

As you might have noticed, **this is a fairly long post**. My hope is that this serves as an extensive reference for the topic of "GAT workarounds". I try to discuss every important detail and show several use cases. I expect most readers to skip large parts of this post.

If you don't have the time, reading the summary at the very end is the best idea. Additionally, each workaround has its own "rating" section that discusses the workaround's advantages and disadvantages. You can use this table of contents to jump around:

- [The problem](#the-problem) (quick recap of the problem we're trying to solve)
  - [A better `io::Lines`](#a-better-iolines)
  - [Another useful example: mutable windows of a slice](#another-useful-example-mutable-windows-of-a-slice)
  - [Not the solution we want: the crate `streaming-iterator`](#not-the-solution-we-want-the-crate-streaming-iterator)
- [Workaround A: lifetime parameter in trait](#workaround-a-lifetime-parameter-in-trait)
  - [Disadvantages](#disadvantages)
  - [Rating](#rating)
- [Workaround B: HRTBs & the family trait pattern]()
  - [Family traits](#family-traits)
  - [The workaround](#the-workaround)
  - [Disadvantages](#disadvantages-1)
  - [Rating](#rating-1)

<br />
<br />
<br />

---

# The problem

Let's quickly recap the problem we're trying to solve. In this post, we use the *streaming iterator* as a motivating example. Note that there are far more use cases that benefit from the workarounds in this post. One such use case is in a project of mine: I started searching for workarounds because I badly needed GATs for said project and waiting until they are implemented was not an option. But let's get back to streaming iterators.

As an example, let's take a look at [`std::io::Lines`](https://doc.rust-lang.org/stable/std/io/struct.Lines.html): an iterator that can iterate over lines of an [`io::BufRead`](https://doc.rust-lang.org/stable/std/io/trait.BufRead.html). That type is very useful, but has a major problem: it returns `io::Result<String>`. This means that a new `String` object is allocated for every line, making the iterator pretty slow. This is a common pitfall and source of confusion (for example, see [this question on StackOverflow](https://stackoverflow.com/q/45455275/2408867)).


## A better `io::Lines`

The better solution would be to manage a `String` buffer in the iterator and yielding `io::Result<&str>` as item. That way the allocated buffer is reused for all lines. So why doesn't `io::Lines` do that? Let's try it:

```rust
struct Lines<B: BufRead> {
    reader: B,
    buffer: String,
}

impl<B: BufRead> Iterator for Lines<B> {
    type Item = io::Result<&str>;
    fn next(&mut self) -> Option<Self::Item> { â€¦ }
}
```

Compiling this results in:

```
error[E0106]: missing lifetime specifier
   |
10 |     type Item = io::Result<&str>;
   |                            ^ expected lifetime parameter
```

We can't just omit lifetime parameters, except in functions where lifetime elision kicks in. What lifetime do we need to annotate here? The lifetime of `&self`, as the `&str` is borrowed from the `String` in `Lines`. But this is not possible!

```rust
impl<B: BufRead> Iterator for Lines<B> {
    type Item = io::Result<&'s str>;
    fn next<'s>(&'s mut self) -> Option<Self::Item> { â€¦ }
}
```

This results in `undeclared lifetime` as the lifetime `'s` is only visible in the scope of the function definition.

With GATs, we can easily solve this problem (if we were to redefine the `Iterator` trait!):

```rust
trait IteratorGat {
    type Item<'s>;
    fn next<'s>(&'s mut self) -> Option<Self::Item<'s>>;
    // ^ or just remove lifetimes in the function signature: lifetime
    // elision is able to handle this
}

impl<B: BufRead> Iterator for Lines<B> {
    type Item<'s> = io::Result<&'s str>;
    fn next<'s>(&'s mut self) -> Option<Self::Item<'s>> { â€¦ }
}
```


## Another useful example: mutable windows of a slice

In the case of `io::Lines` we want to return a reference to memory inside the iterator. But using the `self` lifetime can be used in other situations as well, making it possible to safely express certain constructs. A good example is a `WindowsMut` iterator. Already today there exists [`slice::Windows`](https://doc.rust-lang.org/stable/std/slice/struct.Windows.html) which is an iterator yielding overlapping windows of a slice. For example, `[1, 2, 3, 4].windows(2)` would yield the elements `&[1, 2]`, `&[2, 3]` and `&[3, 4]`.

Sometimes it would be useful to have a `WindowsMut`, yielding mutable overlapping windows of a slice. But this, again, is not possible with the current iterator trait. The following simple example shows that we could easily break the world:

```rust
let mut slice = ['a', 'ðŸ’£', 'c'];
let mut it = slice.windows_mut(2);
let x = it.next().unwrap();
let y = it.next().unwrap();

// Oops, now we have two mutable references to the second element:
// `&mut x[1]` and `&mut y[0]`
```

The above example would not be rejected by the compiler because `x` is not borrowed from `it`, so `it` is not "locked" as mutably borrowed. Thus the compiler let's us happily call `next()` a second time. Fortunately, it's not possible to write such an `Iterator` implementation in safe Rust. Trying it always results in errors ([see on Playground](https://play.rust-lang.org/?gist=ea50e340ee159d722aadaa1ed9695921&version=stable&mode=debug&edition=2015)).

With GATs it would be possible to have `WindowsMut` as the compiler would understand that the item is borrowed from the iterator. As such, a second `next()` call wouldn't be allowed while an item still existed.

## Not the solution we want: the crate `streaming-iterator`

[The crate `streaming-iterator`](https://crates.io/crates/streaming-iterator) works around this limitation by defining [this trait](https://docs.rs/streaming-iterator/0.1.4/streaming_iterator/trait.StreamingIterator.html):

```rust
pub trait StreamingIterator {
    type Item: ?Sized;
    fn advance(&mut self);
    fn get(&self) -> Option<&Self::Item>;   // <-- reference
}
```

This main point to notice is that `Self::Item` is always returned by reference and not by value. This is certainly useful in some situations, but now the trait doesn't allow returning items by value -- which is also a limitation. Thus this solution requires two traits to work in all situations.

That's not what we want. **In this post we are interested in solutions that only require one trait and where the impl can choose whether or not the `Item` borrows from `self`.** This will solve a range of other problems as well, instead of only the streaming iterator one.


<br />
<br />


# Workaround A: lifetime parameter in trait

Our first idea is to put the lifetime parameter on the trait itself and using it in the `self` parameter:

```rust
trait Iterator<'s> {
    type Item;
    fn next(&'s mut self) -> Option<Self::Item>;
}
```

This allows to use the lifetime parameter in the `Item` definition. But it also allows to ignore the lifetime parameter and have an `Item` that doesn't borrow from `self`:

```rust
impl<'s, B: BufRead> Iterator<'s> for Lines<B> {
    // Streaming iterator: we borrow from `self`
    type Item = io::Result<&'s str>;
    fn next(&'s mut self) -> Option<Self::Item> { â€¦ }
}

impl<'s> Iterator<'s> for Fibonacci {
    // "Normal" iterator: not borrowing from self
    type Item = u64;
    fn next(&'s mut self) -> Option<Self::Item> { â€¦ }
}
```

This is very promising! With the Fibonacci iterator, we can have multiple items at the same time, which is perfectly safe. On the other hand, we cannot have two items at the same time from the `Lines` iterator, which is also desired behavior (remember: there is only one string buffer, so we only store one line at a time).

```rust
let mut fib = Fibonacci::new();
let a = fib.next().unwrap();
let b = fib.next().unwrap(); // <-- works


let reader = io::Cursor::new(b"abc\ndef\nghi");
let mut lines = Lines::new(reader);
let line_1 = lines.next();
let line_2 = lines.next();  // <-- error: cannot borrow `lines` as mutable
                            //     more than once at a time
```

## Disadvantages

However, there are several problems with this workaround. First of all: the trait has a lifetime parameter. This means that a lifetime parameter is necessary every time the trait is used (as bound, for example) and thus *infects* other signatures. Let's try to write a function that counts the number of items in an iterator:

```rust
fn count<I>(mut iter: I) -> usize
where
    I: Iterator<'?>,  // <-- we need a lifetime
{ â€¦ }
```

There are multiple ways one could try to solve this:

- **`fn count<'s, I: Iterator<'s>>(mut iter: I)` (lifetime parameter in the function)**: this doesn't work. Generic parameters of the functions are choosen by the caller, not the callee. The problem is that we own the iterator (it lives in our stack frame) and thus we have to choose the lifetime. The caller couldn't possibly know the correct lifetime. And indeed, we get a compiler error.

  It's also important to note that this doesn't work because traits are invariant in respect to their parameters. So if we know that a type implements `Iterator<'x>`, we can't know if the type also implements `Iterator<'y>` for any lifetime `'y != 'x` (even if `'y` outlives `'x` or the other way around).

- **`I: for<'s> Iterator<'s>` (HRTBs)**: with the higher ranked trait bounds syntax we say that `I` needs to implement `Iterator<'s>` for every possible lifetime. Now we can choose the fitting lifetime for our stack frame and call `next()`. Good!

  But we have a new problem: requiring the trait bound for all possible lifetimes is pretty restricting. What we actually would like to say is "for all lifetimes outlived by `I`, `I` has to implement `Iterator`" (but it's impossible to express this). The iterator `impl`s we have seen so far won't cause problems, but imagine how the `impl` for `WindowsMut` would look like:

  ```rust
  impl<'a, 's, T: 's> Iterator<'s> for WindowsMut<'a, T> {
      type Item = &'s mut [T];
      â€¦
  }
  ```

  Here, the `T: 's` bound is required to be able to express the reference for `Item`. But this restricts the `impl`! This bound plus `for<'s> Iterator<'s>` is equivalent to `for<'s> T: 's` which also includes `T: 'static`. The effect is that `count` only works with `WindowsMut` if `T` is `'static`. Needlessly restrictive!
- **`fn count<'s, I>(iter: &'s mut I)` (iterator by reference)**: this time we allow the caller the choose the lifetime by passing the iterator by reference. In theory, this is good: now the iterator doesn't live in our stackframe and the reference we get already has the correct lifetime for the `next()` call.

  And indeed, we can call `next()`. *Once*. Since the `next()` call requires a mutable `self`, calling it a second time results in a "cannot borrow `*iter` as mutable more than once at a time". I won't get into the details here, but this is simply how the borrow checker works. Usually the borrow checker will try to find the smallest possible lifetime for a call -- in order to "block" the reference for the smallest possible time/scope. But in this case, there is only one possible lifetime for the call: `'s`. Again: traits are invariant over their parameters, so the compiler doesn't have a choice.

  This is not a problem for methods with immutable receiver, so there are situations where this works. However, this is only possible if you are able to take the object by reference. Sometimes that's not possible!

Furthermore, adding bounds for the associated type (`Item`) is not fun. Take a look at this:

```rust
where
    I: for<'s> Iterator<'s>,
    I::Item: Clone, // <-- error: cannot extract an associated type from a
                    //     higher-ranked trait bound in this context
```

Instead you have to write:

```rust
where
    I: for<'s> Iterator<'s>,
    for<'s> <I as Iterator<'s>>::Item: Clone,
```

Uhg!

<small markdown="1">(This isn't that big of a problem with [RFC 2289](https://github.com/rust-lang/rfcs/pull/2289), but that's also not yet implemented...)</small>

## Rating

You can get fairly far with this workaround, but there are a ton of annoyances and eventually you'll hit a real limitation you cannot work around. Having a lifetime parameter in the trait is also semantically wrong and pollutes signatures everywhere.

I worked with this approach for a few weeks in my codebase and nearly lost my mind. Frequent super strange lifetime errors are not fun...

You can play with this workaround in [this playground](https://play.rust-lang.org/?gist=b366685a47e465b1baa4d25df9c0dadd&version=stable&mode=debug&edition=2015). It includes most of the code shown above.

<br />
<br />

# Workaround B: HRTBs & the family trait pattern

In the last section, we already saw HRTBs (**h**igher **r**anked **t**rait **b**ounds) which allow us to express trait bounds that are generic over lifetimes. As it already carries "higher ranked" in its name, it's not surprising that this feature allows us to get one step closer to HKTs in today's Rust.

But to use this power, we need something else: the family trait pattern.


## Family traits

Nikolas Matsakis introduced that pattern in [one of his blog posts about GATs](http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/#introducing-type-families) (formerly known as ATC, associated type constructors). He used that pattern to show that GATs are more powerful than one would initially assume. But as it turns out, we can use the same idea without GATs.

Said pattern is made of two parts:

- **Family types**: to the type system, these are normal types. But semantically, they *represent* type constructors (generic types without their generic parameters applied). For example, the type `VecFamily` could *represent* the type constructor `Vec`.
- **Family trait**: a trait that abstracts over some family types.

The trick is how to actually use the type constructor that is being represented. For that we use associated types and treat the family type as a function from types/lifetimes to type. Remember that traits with associated types allow us to model type level functions. (*Side note*: this can be used to do arbitrary computations at compile time, see [`typenum`](https://crates.io/crates/typenum) for example.)

The associated type is the output of our type level function. The only question is how to pass the input parameters to the "function". One possibility are GATs:

```rust
trait CollectionFamily {
    type Collection<T>;
}

enum VecFamily {}
impl CollectionFamily for VecFamily {
    type Collection<T> = Vec<T>;
}

fn generic_over_collection<C: CollectionFamily>() {
    // Here, we can basically treat `C` as a type constructor or
    // type level function: we choose different `T`s and get a new
    // type for each.
    let _: C::Collection<u32> = unimplemented!();
    let _: C::Collection<bool> = unimplemented!();
}

// Call it:
generic_over_collection::<VecFamily>();
```

Similarly, one could create other families (e.g. `LinkedListFamily`) that would represent other collection types. The important point to understand here:

**The family trait pattern works by "delaying" the application of generic parameters. For each type constructor of interest, a family type is created that *represents* that type constructor. Through a trait, that family type can be used to construct types.**

While GATs make this pattern easier and more powerful to use, it still works without. The other way to pass the input parameter is via the trait:

```rust
trait CollectionFamily<T> {
    type Collection;
}

enum VecFamily {}
impl<T> CollectionFamily<T> for VecFamily {
    type Collection = Vec<T>;
}
```

However, we notice a problem when we try to use it as above:

```rust
//                            vvvvvv
fn generic_over_collection<C: for<T> CollectionFamily<T>>() {
    // Slightly more verbose to use the type constructor
    let _: <C as CollectionFamily<u32>>::Collection = unimplemented!();
    let _: <C as CollectionFamily<bool>>::Collection = unimplemented!();
}
```

HRTBs only work for lifetime parameters at the moment. So this workaround -- as the others -- only works for lifetime parameters.

<small markdown="1">*Note*: we can't write `<T, C: CollectionFamily<T>` because then the caller (not the callee) chooses `T`. We had a similar situation above.</small>


## The workaround

Putting everything together, we get this solution:

```rust
// The family trait for type constructors that have one
// input lifetime.
trait FamilyLt<'a> {
    type Out;
}

// A family which represents a type constructor that always
// returns `T` (thus "id").
struct IdFamily<T: ?Sized>(PhantomData<T>, !);
impl<'a, T: ?Sized> FamilyLt<'a> for IdFamily<T> {
    type Out = T;
}

// Represents references to `T`.
struct RefFamily<T: ?Sized>(PhantomData<T>, !);
impl<'a, T: 'a + ?Sized> FamilyLt<'a> for RefFamily<T> {
    type Out = &'a T;
}
```

Several things to note here:

- We defined two families already: one for references to `T` and one for `T` by value.
- This type `T` of the families is generic, but that parameter is not the one we want to delay applying. So it's fine.
- The `!` is the never type which makes sure that the family types are never instantiated. This is not strictly necessary for this workaround.

Let's finally define our `Iterator` trait with it:

```rust
trait Iterator {
    // This basically reads: "`Item` is a function from any
    // lifetime to a type".
    type Item: for<'a> FamilyLt<'a>;

    // "Use" the function here to get the constructed type.
    fn next<'s>(&'s mut self)
        -> Option<<Self::Item as FamilyLt<'s>>::Out>;
}
```

A bit verbose, but it works. Now we can implement `Lines` like this:

```rust
impl<B: BufRead> Iterator for Lines<B> {
    // We simplify things a bit here: instead of `io::Result<&str>`
    // (as above), we simply return `&str`. See the playground link
    // below for the full version.
    type Item = RefFamily<str>;

    fn next<'s>(&'s mut self)
        -> Option<<Self::Item as FamilyLt<'s>>::Out>
    { â€¦ }
}
```

It works! For the Fibonacci iterator we would set `Item` to `IdFamily<u64>` which also works as expected.

This workaround has a major advantage over the workaround A: the lifetime parameter is not in the trait anymore! This means that certain things are easier to express and won't cause problems anymore. Look how simple the `count` example from above has become with this solution:

```rust
fn count<I: Iterator>(mut iter: I) -> usize { â€¦ }
```

Also nice: we can have multiple items from the Fibonacci iterator in scope at the same time, while the compiler won't let us have multiple items of the `Lines` iterator. Perfect!


## Disadvantages

Unfortunately, this approach suffers from some of the same limitations as workaround A. In particular, our usage of HRTBs leads to some unnecessarily strict requirements. Let's take a look at how we would implement `Iterator` for `WindowsMut`:

```rust
// A new family for mutable references
struct MutRefFamily<T: ?Sized>(PhantomData<T>, !);
impl<'a, T: 'a + ?Sized> FamilyLt<'a> for MutRefFamily<T> {
    type Out = &'a mut T;
}

//          vvvvvvv
impl<'a, T: 'static> Iterator for WindowsMut<'a, T> {
    type Item = MutRefFamily<[T]>;
    â€¦
}
```

Without the `'static` bound of `T`, the compiler refuses to compile this. Why? Remember how `Item` was defined in the trait: `type Item: for<'a> FamilyLt<'a>`. But the impl for `MutRefFamily` bounds `T` with `'a`. With the same logic we already applied above, this means that `T` needs to be `'static`.

Additionally, due to the use of HRTBs, specifying trait bounds for the real `Item` type is still ugly:

```rust
where
    I: Iterator,
    for<'a> <I::Item as FamilyLt<'a>>::Out: Display,
```

## A slight variation

One idea to get rid of HRTBs is to move the `FamilyLt` bound to the method:

```rust
trait Iterator {
    type Item;  // <-- no bound

    fn next<'s>(&'s mut self)
        -> Option<<Self::Item as FamilyLt<'s>>::Out>
    where
        Self::Item: FamilyLt<'s>;  // <-- bound, but not HRTB
}
```

While this requires [a little workaround of its own](https://stackoverflow.com/q/51638863/2408867), this actually looks very promising at first. We can successfully compile most of what we want. But once we want to use `Iterator` as a trait bound, we are in trouble again:

```rust
fn count<I: Iterator>(mut iter: I) -> usize {
    iter.next();
    //   ^^^^ the trait `FamilyLt<'_>` is not implemented
    //        for `<I as Iterator>::Item`
    â€¦
}
```

Right... with only `Iterator` as bound, we cannot assume that `FamilyLt` is implemented for `Item`, so we cannot call `next()`. The only solution to solve it in this case is to -- you guessed it -- add a HRTB to the signature of `count`. *Sigh*.

You can find the full code of this variation [here](https://play.rust-lang.org/?gist=9bea8ed57d6641c12199b61ea4b2787f&version=nightly&mode=debug&edition=2015).


## Rating

In this section we saw that we can use the family trait pattern even without GATs to get some way to represent HKTs. That way we successfully removed the lifetime parameter from the `Iterator` trait, but now we have a lifetime parameter in another trait. This change helps in a few situations, but some of the core issues remain:

- Needlessly strict lifetime requirements on some type parameters emerge.
- Bounding the item type is super verbose (so it still pollutes most signatures it appears in).

This approach certainly works in a couple of situations and while it requires a bit more boilerplate code, it has a few advantages over workaround A. But you should certainly be aware of the limitations this workaround has.

All code I've shown above (and more) can be found [in this Playground](https://play.rust-lang.org/?gist=2d0f87f3f7a60a70b14a871760f4b91e&version=nightly&mode=debug&edition=2015). There you can play around with this workaround for yourself.

<small markdown="1">(Something very similar to this approach [has been suggested in the RFC thread about GATs](https://github.com/rust-lang/rfcs/pull/1598#issuecomment-215984749))

<br />
<br />

# Workaround C: wrapper types with the family pattern (TODO)



[gats-tracking-issue]: https://github.com/rust-lang/rust/issues/44265
